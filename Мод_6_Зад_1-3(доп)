/*Задание 1. Откройте по ссылке SQL-запрос.
· Сделайте explain analyze этого запроса.
· Основываясь на описании запроса, найдите узкие места и опишите их.
· Сравните с вашим запросом из основной части (если ваш запрос изначально укладывается в 15мс — отлично!).
· Сделайте построчное описание explain analyze на русском языке оптимизированного запроса*/

explain analyze
select distinct cu.first_name  || ' ' || cu.last_name as name, 
	count(ren.iid) over (partition by cu.customer_id)
from customer cu
full outer join 
	(select *, r.inventory_id as iid, inv.sf_string as sfs, r.customer_id as cid
	from rental r 
	full outer join 
		(select *, unnest(f.special_features) as sf_string
		from inventory i
		full outer join film f on f.film_id = i.film_id) as inv --высокие затраты 263.41
		on r.inventory_id = inv.inventory_id) as ren 
	on ren.cid = cu.customer_id 
where ren.sfs like '%Behind the Scenes%' --самые высокие затраты 572.62
order by count desc;--cost 1089 time 195 ms

/*Per node type stats:
----------------------------------------------------
|node type				|count|	sum of times| % of query|
---------------------------------------------------------
|Bitmap Heap Scan		| 1	  | 44.892 ms	| 8.9 %     |
|Bitmap Index Scan		| 1	  | 27.434 ms	| 5.4 %     |
|Hash					| 1	  | 5.111 ms	| 1.0 %     |
|Hash Full Join			| 1	  | 19.530 ms	| 3.9 %     |
|Index Scan				| 1   | 51.792 ms	| 10.3 %    |
|Nested Loop Left Join  | 2	  | 130.133 ms	| 25.8 %    |
|ProjectSet				| 1	  | 40.123 ms	| 7.9 %     |
|Seq Scan				| 2	  | 11.929 ms	| 2.4 %     |
|Sort					| 2	  | 95.597 ms	| 18.9 %    |
|Subquery Scan			| 1	  | 25.208 ms	| 5.0 %     |
|Unique					| 1	  | 15.631 ms	| 3.1 %     |
|WindowAgg				| 1	  | 37.370 ms	| 7.4 %     |
---------------------------------------------------------

План выполнения:
-> отбор уникальных значений (затраты 0.02)
	-> сортировка результата отбора в select (затраты 0.8)
		-> выполение оконной функции (затраты 0.1)
			-> сортировка по customer_id (затраты 0.07)
				-> соединение слева результата сканирования таблицы customer с результатом предыдущего сканирования (затраты 1.17)
					-> соединение слева результата предыдущего сканирования с результатом сканирования таблицы таблицы rental (затраты 73.83)
						-> сканирование предыдущего подзапроса, фильтр по условию (затраты 572.62)
							-> разворачивание массива специальных атрибутов (затраты 263.41)
								-> полное внешнее соединение таблиц film и inventory (затраты 24.58)
									-> сканирование таблицы inventory (затраты 70.81)
									-> сканирование таблицы film (затраты 64.00), запись в память
						-> сканирование по индексу таблицы rental и таблицы из подзапроса (затраты 14.09)
							-> сканирование по индексу внешнего ключа таблицы inventory и таблицы из подзапроса (затраты 4.32)
					-> сканирование таблицы customer по индексу первичного ключа (затраты 0.3)
*/

--explain (format json) https://tatiyants.com/pev https://explain.depesz.com
explain analyze
select c.customer_id,last_name||' '||first_name,count(rental_id)
from film f
	join inventory i using (film_id)
	join rental r using (inventory_id)
	right join customer c using (customer_id)
where f.film_id in (
					select film_id
					from film
					where special_features @> array['Behind the Scenes']
					)
group by 1,2
order by 1;--cost 887 time 58 ms
					
/* Per node type stats:
------------------------------------------------
|node type	    |count|sum of times	|% of query|
------------------------------------------------
|Hash	        |  4  | 15.889 ms	| 5.9 %    |
|Hash Join	    |  4  | 182.380 ms	| 67.2 %   |
|HashAggregate	|  1  | 27.030 ms	| 10.0 %   |
|Seq Scan	    |  5  | 43.979 ms	| 16.2 %   |
|Sort	        |  1  | 2.062 ms    | 0.8 %    |
------------------------------------------------

План выполнения:
-> сортировка (затраты 29.13)
	-> выборка столбцов: группировка, вычисление (затраты 73.73)
		-> соединение с таблицей customer (затраты 73.46)
			-> соединение с таблицей film (затраты 35.26)
				-> соединение предыдущего соединения с результатом вложенного запроса (затраты 49.02)
					-> соединение таблиц rental и inventory (затраты 99.42)
							-> сканирование таблицы rental (затраты 310.44), запись в память
							-> сканирование таблицы inventory (затраты 70.81), запись в память
								-> сканирование таблицы film (вложенный запрос,фильтр по условию) (затраты 66.50), запись в память
							-> сканирование таблицы film (затраты 64.00), запись в память
							-> сканирование таблицы customer (затраты 14.99), запись в память
Вывод: больше всего ресурсов и времени требует соединение таблиц rental и inventory и сканирование таблицы rental*/

--Задание 2. Используя оконную функцию, выведите для каждого сотрудника сведения о первой его продаже

select fs.staff_id,f.film_id,title,amount,payment_date,last_name,first_name 
from  
	(select *
	from
		(select *,lag(payment_date) over (partition by staff_id order by payment_date) as sale_before
		from payment) as pay--1555
	where sale_before is null
	) as fs--1701
join rental r using (rental_id)--2123
join inventory i using (inventory_id)--2146
join film f using (film_id)--2171
join customer c on c.customer_id=fs.customer_id;--2194
		
/*Задание 3. Для каждого магазина определите и выведите одним SQL-запросом следующие аналитические показатели:
· день, в который арендовали больше всего фильмов (в формате год-месяц-день);
· количество фильмов, взятых в аренду в этот день;
· день, в который продали фильмов на наименьшую сумму (в формате год-месяц-день);
· сумму продажи в этот день*/

--explain analyze
with cte1 as
	(select store_id,
			rental_date,
			count(film_id) as f_count,
			row_number () over (partition by store_id order by count(film_id) desc) as f_number
	from
		(select store_id,rental_date::date,film_id
		from rental r
			join inventory i using (inventory_id)
		) q
	group by 1,2
	),--31-07 354/02-08 343
	cte2 as
	(select store_id,
			payment_date,
			sum(amount) as a_sum,
			row_number () over (partition by store_id order by sum(amount)) as a_number
	from
		(select store_id,payment_date::date,amount
		from payment p
			join rental r using (rental_id)
			join inventory i using (inventory_id)
		) w
	group by 1,2
	)--14-02 73,84/14-02 42.89 
select cte1.store_id,
		rental_date,
		f_count,
		payment_date,
		a_sum
from cte1
	join cte2 on cte1.store_id=cte2.store_id and f_number=1 and a_number=1;--cost 5379 time 76 ms
